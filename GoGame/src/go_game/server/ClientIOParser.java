package go_game.server;

import java.util.Collections;

import go_game.Board;
import go_game.Mark;
import go_game.protocol.AdditionalConstants;
import go_game.protocol.Constants4;


// TODO: Auto-generated Javadoc
/**
 * The Class ClientIOParser.
 */
public class ClientIOParser implements Constants4, AdditionalConstants {

	/** The client. */
	private ClientParsing client;
	
	/** The parsed output string. */
	private String parsedOutputString;
	
	/** The parsed input string. */
	private String parsedInputString;
	
	/** The last board. */
	private Board lastBoard;
	
	/**
	 * Instantiates a new client io parser.
	 *
	 * @param client the client
	 */
	// Constructor
	public ClientIOParser(ClientParsing client) {
		this.client = client;

	}

	// ------------------------------------------
	// Interpret the input
	/**
	 * Parses the input.
	 *
	 * @param inputString the input string
	 * @return the string
	 */
	// ------------------------------------------
	public String parseInput(String inputString) {
		String stringAfterCommand = "";
		String[] stringParts = inputString.split(DELIMITER);
		String command = stringParts[0].trim().toUpperCase();
		int amountArgs = stringParts.length - 1;
//		System.out.println("Parsing: '" + command + "' with " + amountArgs + " arguments.");
		if (amountArgs > 0) {
			stringAfterCommand = inputString.substring(stringParts[0].length());
//			System.out.println("Parsing: " + stringAfterCommand);
//			System.out.println("Parsing: " + stringParts[1]);
		}
		String parsedInputString = "";

		// GET THE STATE OF THE CORRESPONDING CLIENTHANDLER
		//TODO: CLIENTIOPARSER
		switch (command) {

		// GENERAL commands ------------------------------------------
		case VERSION:
			client.print("Current protocol version: " + VERSION);
			break;
		case "SERVER_PORT":
			client.print("Current server port: " + SERVER_PORT);
			break;
			
			// TIMEOUTS
		case TIMEOUTEXCEEDED:
//			client.print("Current you have " + TIMEOUTSECONDS + " seconds until time-out");
			parsedInputString = "Your thinking time has passed, you lose the game! \n";
			break;
		

			// Questions ------------------------------------------
		case NEWPLAYERACCEPTED:
			parsedInputString = "Dear " + client.getClientName() + ", you have been accepted to access the lobby, ◕_◕";
			break;
		case OPTIONS:
			parsedInputString = stringAfterCommand;
			break;

			// Chatting
		case CHAT:
			parsedInputString = stringAfterCommand;
			break;
			
			// CHALLENGING
		case AVAILABLEPLAYERS:
			parsedInputString = stringAfterCommand;
			break;
		case YOUVECHALLENGED:
			parsedInputString = "The challenge with " + stringParts[1].trim() + " is on its way...Sit down, relax and wait for an response. ¯\\_(ツ)_/¯ (or sent QUIT to cancel the challenge)\n ";
			break;
		case YOURECHALLENGED:
			parsedInputString = "You are challenged by '" + stringParts[1].trim() + "', respond with '" + CHALLENGEACCEPTED + "' or '" + CHALLENGEDENIED + "'.";
			break;
		case CHALLENGEACCEPTED:
			parsedInputString = "Your challenge has been accepted! Get ready for an epic match \\(°□°)/";
			break;
		case CHALLENGEDENIED:
			parsedInputString = "Your challenge has been denied! Find a new friend... ༼ つ ◕_◕ ༽つ";
			break;
		case GAMESTART:
			parsedInputString = "Starting the game as " + stringParts[1] + " on a board (" + stringParts[2] + "x" + stringParts[2] + ") as " + stringParts[3] + "\n";
			// Create the initial board
			lastBoard = new Board(Integer.parseInt(stringParts[2]));
			break;
			
			// OBSERVER COMMANDS
		case CURRENTGAMES:
			// TODO DISPLAY THE CURRENT GAMES
			parsedInputString = stringAfterCommand;
			
			break;
		case NOGAMESPLAYING:
			parsedInputString = "No games are currently played.\n";
			break;
		case OBSERVEDGAME:
			// TODO DISPLAY THE CURRENT GAME
			parsedInputString = "Observering: " + stringAfterCommand;
			break;
			// Display board commands ------------------------------------------
		case BOARD:
//			System.out.println("The board is being parsed by the client:\n");
			parsedInputString = showBoard(stringParts[1]);
			break;
			
			// GAME COMMANDS
		case MOVE:
//			System.out.println("The move is being parsed\n");
			//TODO GET THE MOVE COMMAND
			if (amountArgs == 2) {
				// Someone has passed
				parsedInputString = "Pass made: " + stringParts[2] + " by " + stringParts[1];
			} else if (amountArgs == 3)  {
				parsedInputString = "Move made: (" + stringParts[2] +", " + stringParts[3] + ") by " + stringParts[1];
			} else {
				parsedInputString = "Something went wrong.\n";
			}
//			parsedInputString = stringAfterCommand;
			break;
		case HINT:
			if (amountArgs == 2) {
			System.out.println("Hint generated by server: \n");
			int xCo = Integer.parseInt(stringParts[1]);
			int yCo = Integer.parseInt(stringParts[2]);
			Board copyBoard = lastBoard.deepCopy();
			copyBoard.setField(xCo, yCo, Mark.HH);
			System.out.println(copyBoard.toStringOnCommandLine());
//			parsedInputString = stringAfterCommand;
			} else {
				System.out.println("Something went wrong...");
			}
			break;
		case AVAILABLESTRATEGIES:
			parsedInputString = "The available strategies are: " + stringAfterCommand;
			break;
		case STATUS:
			parsedInputString = stringAfterCommand;
			break;
		case WAITFOROPPONENT:
			parsedInputString = "Status has been changed. Sit down, relax and wait for an opponent. ¯\\_(ツ)_/¯ \n";
			break;
		
			// ENDGAME COMMANDS
		case GAMEOVER:
			parsedInputString = "\n The game has ended... \n";
			if (stringParts[1].equals(VICTORY)) {
				parsedInputString = parsedInputString + "\n YOU HAVE WON!!! ♪┏(°.°)┛┗(°.°)┓┗(°.°)┛┏(°.°)┓ ♪ \n";
			} else if (stringParts[1].equals(DEFEAT)) {
				parsedInputString = parsedInputString + "\n You have lost!!! (╯°□°）╯︵ ┻━┻ \n";
			} else if (stringParts[1].equals(DRAW)) {
				parsedInputString = parsedInputString + "\n The game has resulted in a draw!!! \n";
			} else {
				parsedInputString = parsedInputString + " but still something went wrong! \n";
			}
			// TODO: PARSE VICTORY OR DEFEAT AS GAMEOVER + DELIMITER + DEFEAT
			
			break;
//		case VICTORY:
//			// TODO: PARSE VICTORY OR DEFEAT AS GAMEOVER + DELIMITER + DEFEAT
//			parsedInputString = "\n YOU HAVE WON!!! ♪┏(°.°)┛┗(°.°)┓┗(°.°)┛┏(°.°)┓ ♪ \n";
//			break;
//		case DEFEAT:
//			parsedInputString = "\n You have lost!!! (╯°□°）╯︵ ┻━┻ \n";
//			break;
//		case DRAW:
//			parsedInputString = "\n The game has resulted in a draw!!! \n";
//			break;
			
			// ------------------------------------------
			// FAILURES
			// ------------------------------------------
		case FAILURE: 
			
			String errorType = stringParts[1].trim();
			
			//			clientHandler.sendMessageToClient(errorType);
			//			clientHandler.sendMessageToServer(errorType);
			if (errorType.equalsIgnoreCase(NOTAPPLICABLECOMMAND)) {
				parsedInputString = "This command is not applicable in your current state.\n";
			} else if (errorType.equalsIgnoreCase(UNKNOWNCOMMAND)) {
				parsedInputString = "This is an unknown command. Please use a known command, see 'GETOPTIONS'.\n";
			} else if (errorType.equalsIgnoreCase(ARGUMENTSMISSING)) {
				parsedInputString = "This command comes with other arguments.\n";
			} else if (errorType.equalsIgnoreCase(NOTSUPPORTEDCOMMAND)) {
				parsedInputString = "This command is not supported by the server.\n";
			} else if (errorType.equalsIgnoreCase(INVALIDNAME)) {
				parsedInputString = "The chosen name is invalid (contains spaces or only numbers), choose another name. \n";
				parsedInputString = parsedInputString + "\nEnter a new name using:" + NEWPLAYER + DELIMITER + "<name>";
			} else if (errorType.equalsIgnoreCase(NAMETAKEN)) {
				parsedInputString = "The chosen name was already taken, choose another name. \n";
				parsedInputString = parsedInputString + "\nEnter a new name using:" + NEWPLAYER + DELIMITER + "<name>";
			} else if (errorType.equalsIgnoreCase(NAMENOTALLOWED)) {
				parsedInputString = "The chosen name is not allowed (e.g. on the 'not-allowed' list), choose another name. \n";
				parsedInputString = parsedInputString + "\nEnter a new name using:" + NEWPLAYER + DELIMITER + "<name>";
			} else if (errorType.equalsIgnoreCase(INVALIDMOVE)) {
				parsedInputString = "An invalid move input was performed.\n"; 
			} else if (errorType.equalsIgnoreCase(NOTYOURTURN)) {
				parsedInputString = "Don't try to make moves before your turn! \n "; 
			} else if (errorType.equalsIgnoreCase(ILLEGALARGUMENT)) {
				parsedInputString = "This command is ... "; 
			} else if (errorType.equalsIgnoreCase(OTHERPLAYERCANNOTCHAT)) {
				parsedInputString = "This command is ... "; 
			} else if (errorType.equalsIgnoreCase(PLAYERNOTAVAILABLE)) {
				parsedInputString = "The player you inputted is (currently) not available."; 
			} else if (errorType.equalsIgnoreCase(GAMENOTPLAYING)) {
				parsedInputString = "This command is ... "; 
			} else if (errorType.equals(TIMEOUTEXCEEDED)) {
				parsedInputString = "Your time has exceeded. ";
			}
			break; 
			
			// ---------------------------------------------------------------
			// EXTENSIONS
			// ---------------------------------------------------------------
			// ADDITIONAL COMMANDS
		case GETEXTENSIONS:
			//TODO OPTIONELE COMMANDOS
			break;
		case EXTENSIONS:
			//TODO, lijst van optionele commando's sturen
			break;

		}
		

		
		
		return parsedInputString;

	}
	
	// ------------------------------------------
	// Change the output for sending over the socket
	/**
	 * Parses the output.
	 *
	 * @param outputString the output string
	 * @return the string
	 */
	// ------------------------------------------
	public String parseOutput(String outputString) {
		String[] stringParts = outputString.split(DELIMITER);
		String command = stringParts[0].trim().toUpperCase();
		int amountArgs = stringParts.length - 1;
//		System.out.println("Parsing: '" + command + "' with " + amountArgs + " arguments.");

		switch (command) {

		// GENERAL commands ------------------------------------------
		case VERSION:
			client.print("Current protocol version: " + VERSION);
			break;
		case "SERVER_PORT":
			client.print("Current server port: " + SERVER_PORT);
			break;
		case "TIMEOUTSECONDS":
			client.print("Current you have " + TIMEOUTSECONDS + " seconds until time-out");
			break;
		case NEWPLAYER:
			client.setClientName(stringParts[1]);
			parsedOutputString = outputString;
			break;
			
			//QUITING
		case QUIT:
			parsedOutputString = outputString;
			System.out.println("Clientparser out parsed QUIT");
//			System.exit(0);
			client.shutdown();
			break;
			
			
		case GETHINT:
			parsedOutputString = outputString;
//			client.print("Hint by client: " + "(5,5)");
			break;
		default:
			parsedOutputString = outputString;
			break;
		}

		return parsedOutputString;
	}
	
	/**
	 * Show board.
	 *
	 * @param stringBoard the string board
	 * @return the string
	 */
	public String showBoard(String stringBoard) {
//		System.out.println("Parsing board on client side");
		Board clientBoard = createBoardFromStringRepresentation(stringBoard);
		this.lastBoard = clientBoard;
		return clientBoard.toStringOnCommandLine();
	}

	/**
	 * Creates the board from string representation.
	 *
	 * @param stringBoard the string board
	 * @return the board
	 */
	public Board createBoardFromStringRepresentation(String stringBoard) {
		stringBoard = stringBoard.trim();
		Double dimDouble = (Math.sqrt(stringBoard.length()));
		int dim = dimDouble.intValue();
		Board clientBoard = new Board(dim);
		Mark currentMark = Mark.EMPTY;
		for (int index = 0; index < dim * dim; index++) {
			String stringMarkIndex = Character.toString(stringBoard.charAt(index));
			if (stringMarkIndex.equals(W)) {
				 currentMark = Mark.WW;
			} else if (stringMarkIndex.equals(B)){
				 currentMark = Mark.BB;
			} else if (stringMarkIndex.equals(E)) {
				 currentMark = Mark.EMPTY;
			} else {
				System.out.println("Character not recognized");
			}
			clientBoard.setField(index, currentMark);
		}
		return clientBoard;
	}
}
